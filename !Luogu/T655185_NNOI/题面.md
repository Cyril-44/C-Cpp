帮我对于每个Sub造两组输入，再用以下std跑出输出，作为压缩包发给我
# T655185 扔泥巴

## 题目背景

别人朝我扔泥巴，我拿泥巴埋了他！

## 题目描述

小 A 向小 B 扔了 $n$ 块泥巴，小 B 要拿泥巴种西瓜。泥巴具有丰富的营养，每块泥巴有一份营养。然而，西瓜不乐意了。有 $m$ 个西瓜，你想要种第 $i$ 个西瓜需要 $c_i$ 份营养。同时，你想要种第 $i$ 个西瓜以种了第 $x_i$ 个西瓜为前提。特别的，如果 $x_i = 0$，代表种第 $i$ 个西瓜没有限制。现在小 B 想问你，他最多能种下多少个西瓜。

小 A 不想为难小 B，所以对于所有的满足 $1 \le i \le m$ 且 $x_i \ne 0$ 的 $i$，满足 $c_{x_i} \le c_i$。

## 输入格式

第一行一个 $t$ 代表数据组数。

每组数据：

第一行两个数 $n,m$。

第二行 $m$ 个数，第 $i$ 个代表 $c_i$。

第三行 $m$ 个数，第 $i$ 个代表 $x_i$。

## 输出格式

每组数据输出一个数，代表最多能种的西瓜数。

## 输入输出样例 #1

### 输入 #1

```
1
5 4
1 2 3 2
0 1 1 0
```

### 输出 #1

```
3
```

## 说明/提示

**本题捆绑测试。**
| 子任务  | 特殊性质  | 分值  |
|:-:|:-:|:-:|
| $1$  | $n = 1$  | $5$  |
| $2$  | $m = 1$  | $15$  |
| $3$  | 对于 $1 \le i \le n,x_i = 0$  | $15$  |
| $4$  | 对于 $1 < i \le n,c_i = c_{i-1}$  | $15$  |
| $5$  | $1 \le m \le 10^3$  | $15$  |
| $6$  | $1 \le n \le 100$  | $15$  |
| $7$  | 无  | $20$  |

对于 $100\%$ 的数据，$1 \le n,c_i \le 10^{18},1 \le m,\sum m \le 10^6,1 \le t \le 10,0 \le x_i \le n,x_i \ne i$。

数据保证所有的满足 $1 \le i \le n$ 且 $x_i \ne 0$ 的 $i$，满足 $c_{x_i} \le c_i$。
#include <bits/stdc++.h>
using namespace std;

long long a[1000005];
int x[1000005];
int f[1000005];
int size[1000005];
struct node{
    long long x;int w;
    friend bool operator<(node x,node y){
        return x.x>y.x;
    }
};
int find(int x){
    if (x==f[x]||f[x]==-1) return x;
    return f[x]=find(f[x]);
}
vector<int>p[1000005];
priority_queue<node>q;
int main(){
//    freopen("mud13.in","r",stdin);
//    freopen("mud13.out","w",stdout);
    int t;
    scanf("%d",&t);
    while(t--){
        long long n;int m;
        scanf("%lld%d",&n,&m);
        for(int i=0;i<=m;i++) p[i].clear();
        for(int i=1;i<=m;i++) scanf("%lld",&a[i]);
        for(int i=1;i<=m;i++) scanf("%d",&x[i]);
        for(int i=1;i<=m;i++) f[i]=i,size[i]=1;
        for(int i=1;i<=m;i++){
            int u=find(i),v=find(x[i]);
            if (x[i]!=0){
                if (u==v) f[find(i)]=-1;
                else{
                    if (size[u]<size[v]){
                        f[u]=v;
                        size[v]+=size[u];
                    }
                    else f[v]=u,size[u]+=size[v];
                }
            }    
        }
        for(int i=1;i<=m;i++){
            if (find(i)!=-1){
                p[x[i]].push_back(i);
            }
        }
        while(!q.empty()) q.pop();
        int ans=0;
        node p2;p2.w=0,p2.x=0;
        q.push(p2);
        while(!q.empty()){
            node p1=q.top();
            q.pop();
            if (n<p1.x) break;
            n-=p1.x;
            ans++;
            for(int i=0;i<p[p1.w].size();i++){
                node rt;
                rt.w=p[p1.w][i];
                rt.x=a[rt.w];
                q.push(rt);
            }
        }
        printf("%d\n",ans-1);
    } 
    return 0;
}