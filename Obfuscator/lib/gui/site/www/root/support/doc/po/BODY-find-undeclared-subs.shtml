
<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<LI><A HREF="#options">OPTIONS</A></LI>
	<LI><A HREF="#notes">NOTES</A></LI>
	<LI><A HREF="#examples">EXAMPLES</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<HR>
<H1><A NAME="name">NAME</A></H1>
<P>find-undeclared-subs.pl - find places in perl code where undeclared symbols
are used</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<P><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD><STRONG>find-undeclared-subs.pl</STRONG> [&nbsp;<STRONG>-t</STRONG>&nbsp;<EM>types-of-symbols-to-check</EM>&nbsp;]
<TR><TD><TD>[&nbsp;<STRONG>-P</STRONG>&nbsp;<EM>perl-backend-command</EM>&nbsp;] <EM>file</EM> ...</TABLE></P>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P>This script lists all undeclared subs used in the perl source files 
passed on commandline. The use of this script gives more than plain placing
of <CODE>'use strict'</CODE> in your source since in 
case of <CODE>'use strict'</CODE> the use of undeclared subroutines is detected only at 
runtime when perl has to execute them (i.e. if execution path reached the 
invokation of the undeclared sub). 
In contrast this script examines all execution paths and reports all locations
the undeclared subroutines are used.</P>
<P>It does not check the modules that the analyzed file requires if the modules
are located not in the subdirectories of the directory where the analyzed
file is located.</P>
<P>
<HR>
<H1><A NAME="options">OPTIONS</A></H1>
<DL>
<DT><STRONG><A NAME="item_%2Dt_types%2Dof%2Dsymbols%2Dto%2Dcheck"><STRONG>-t</STRONG> <EM>types-of-symbols-to-check</EM></A></STRONG><BR>
<DD>
Specify use of what types of undeclared symbols you wish to list. 
The <EM>types-of-symbols-to-check</EM> is a string of <EM>symbol prefixes</EM> you
wish to list, listed in any order without any space between them.
Here is a correspondence between <EM>symbol prefixes</EM> and types of symbols:
<DL>
<DT><STRONG><A NAME="item_%26"><STRONG>&amp;</STRONG></A></STRONG><BR>
<DD>
Subroutine
<P></P>
<DT><STRONG><A NAME="item_%24"><STRONG>$</STRONG></A></STRONG><BR>
<DD>
Scalar variable
<P></P>
<DT><STRONG><A NAME="item_%40"><STRONG>@</STRONG></A></STRONG><BR>
<DD>
List variable
<P></P>
<DT><STRONG><A NAME="item_%25"><STRONG>%</STRONG></A></STRONG><BR>
<DD>
Hash variable
<P></P>
<LI>
Symbol table entry
<P></P></DL>
<P>The default value of this argument is <STRONG>&amp;</STRONG> - i.e. the locations of the use
of undeclared subroutines is listed.</P>
<DT><STRONG><A NAME="item_%2DP_perl%2Dbackend%2Dcommand"><STRONG>-P</STRONG> <EM>perl-backend-command</EM></A></STRONG><BR>
<DD>
Specify the invokaction string for the backend. It does not need to specify
the full path of the perl program. This option is intended for passing any 
additional options mostly used for specifying the location of modules your
program requires. The passed string is prepended to the necessary options
used for functionality of this script. The default value of this option is
<EM>perl</EM>.
<P></P></DL>
<P>
<HR>
<H1><A NAME="notes">NOTES</A></H1>
<P>It can list give false alarms for symbols that are not subroutines
(this is a feature of the <STRONG>B::Xref</STRONG> module used as a backend).
So it is only practical to check only the places with the use of undeclared
subroutines (that's the default mode if you don't pass any <STRONG>-t</STRONG> options).
Use the <CODE>'use strict'</CODE> in your source for detecting use of undeclared 
objects of types other than subroutines.</P>
<P>
<HR>
<H1><A NAME="examples">EXAMPLES</A></H1>
<P>The following commandline should list all locations where undeclared hashes
and subroutines are used in files <EM>file1.pl</EM> and <EM>file2.pl</EM>, 
instructing to search for modules in the parent directory:</P>
<PRE>
 find-undeclared-subs.pl -t '%&amp;' -P 'perl -I..' file1.pl file2.pl</PRE>

