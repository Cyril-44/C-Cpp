<!---BEFORE_DOC_CONTENT-->
			    
<h4>Table of contents</h4>
<ul>
<li><a href=#keyfacts>Key facts</a>
<li><a href=#exceptions>Key concept: exceptions - names of symbols that should not be modified</a>
<li><a href=#steps>Steps for obfuscating the project with Perl-Obfus</a>
</ul>


<a name=keyfacts></a>
<h1>Key facts about Perl-Obfus</h1><p>

<ul>
<li>It never overwrites input files.
<li>It has both GUI and command line interfaces. GUI uses command line interface under the hood, but GUI
    adds some handy tools, so GUI interface is more powerfull and feature-rich and is more recommended to use.
    <p>
    It's really greatly recommended to  use GUI interface to set up the project.
    Later you can export scripts (or .bat files for Windows) that allow you to build/rebuild/clean your project
    from command line  - they are called <a href=buildscript.shtml>buildscripts</a>.
    <p>
    And if you insist on never using GUI interface (it's very bad idea!) you can still generate command line
    using GUI on your computer (go to <span class=menuref>Tools &rArr; Command line builder</span>) 
    or online command line builder available 
    <a href=http://stunnix.com/support/interactive/cmd-builder/cl-po.shtml>on our site</a>.
    
<li>Trial version can perform only one kind of transformation for symbol names - by prepending string
    <code>ReplacementFor_</code> to them. This does not limit your ability to evaluate  Perl-Obfus in any way!


    The trial version does allow you to fully evaluate  Perl-Obfus and prepare your project for obfuscation 
    using only trial edition.  
    <p>
    Just imagine that instead of <code>ReplacmentFor_someFunction</code> you'll get  <code>z78a4b2e</code>. 
    Those symbols that got prefix with trial version will become something unreadable when protected by non-trial.
    It's easier to prepare project for obfuscation using this kind of replacement (when some prefix is prepended), 
    so it's called a debug mode. Using debug mode is recommended when using non-trial version of the product too! - 
    as it allows to understand what's going on much easier (you'll get errors looking like
    <tt>"unknown symbol ReplacementFor_someFunction"</tt> 
    instead of <tt>"unknown symbol z72a63be9f"</tt> - the former is much more readable when debugging!).
    <p>
    Once you created a project, prepared it for protection using trial, you can purchase non-trial, just open that 
    project in non-trial edition, click <span class=menuref>Build &rArr; Rebuild all</span> 
    and you'll get your project fully protected.
    So you won't loose any time spent evaluating trial edition.

<li>Default settings and values of parameters are safe and reasonable.
<li>Obfuscation of the project is not as quick as zipping the folder with source code - you have to confiure
    your project (by listing names that should not be modified, called exceptions) 
    and even modify your code a little in case you use eval() in your code
    . So be ready  to spend from hours to days before you get protected version of your code that works correctly
    after obfuscation.
   
</ul>

<a name=exceptions></a>
<h1>Key concept: exceptions - names of symbols that should not be modified</h1><p>

The purpose of Perl-Obfus is to replace symbols with meaningless names.
Apparently, not all symbols can be changed without introducing errors.
For example, names 
    

    

    
of subs that you use from modules shipped with Perl, like <code>getcwd</code> from <code>POSIX.pm</code>, 
    


can not be changed. Names of such symbols
should be added to the list of <b>exceptions</b> - so obfuscator does not change them  
    
<a class=docref href=exceptions.shtml#adding-to-exceptions>adding symbols to exceptions</a>    
.
<p>


<h2>Symbols defined in 3rd-party  modules </h2><p>
If your code calls some functions from 3rd-party  modules  







that  you are not allowed to modify or are shipped with Perl
, you have to list all symbols that you use from those  modules  as exceptions

<a class=docref href=exceptions.shtml#adding-to-exceptions>adding symbols to exceptions</a>    
.

<p>
Perl-Obfus ships with a lot of tools that help generating exceptions for 3rd-party  modules 

<a class=docref href=exceptions.shtml#extract-exceptions>extacting list of symbols</a>    
.



<h2>Exporting symbols to 3rd parties</h2><p>

If your code is in fact a   module  that you sell or distribute, then you have to list as exceptions  
all symbols defining its API
<a class=docref href=exceptions.shtml#adding-to-exceptions>adding symbols to exceptions</a>    
.

Use tools shipped with Perl-Obfus to generate exceptions for API of your  module 

<a class=docref href=exceptions.shtml#extract-exceptions>extacting list of symbols</a>    





<h2>Dealing with names of symbols in strings</h2><p>
<a name=use_objname></a>

    Find all places in your code that uses symbol names to make a reference. Add the following 
    lines to the begining of those files (or make sure that the definitions of these 
    functions are visible to your code from some base module):
<pre>
    #the definition for SN and SNS
    BEGIN{eval('sub SNS{@_;}sub SN{$_[0];}');}
	#SN takes just 1 symbol as argument. 
	#SNS takes a LIST of symbol names as arguments.
</pre><p></p>

    Most typical is update necessary to <code>use vars</code> statement, where you will have to wrap 
the list of symbol names into call of <code>SNS</code>:
<pre>
#before
    use vars qw($foo @bar %blah);
#after
    use vars SNS(qw($foo @bar %blah));
</pre><p></p>
    Sometimes you may have to put that <code>use vars</code> block inside <code>BEGIN{}</code> 
    block if <code>use vars</code> block is at the topmost level in your file.
    <p>



Sometimes, your code refers to names of functions or variables inside the strings, e.g. in strings passed to



 

 
<code>eval()</code> function.


 What to do in such case:
<dl>
<dt>If the name of the symbol inside the string is computed at runtime</dt>


    <dd>(e.g. entered by the user ), then the only
	option you have is to list all possible names of symbols that can be used this way in your code
	in the list of exceptions   
<a class=docref href=exceptions.shtml#adding-to-exceptions>adding symbols to exceptions</a>    
.
	<p>

    Sample:
<pre>
sub f1 {}
sub f2 {}

my $subnm = CGI::param('what'); #assuming it can be 'f1' or 'f2', 
	    #you have to put both f1 and f2 to list of exceptions
&$f1();
</pre><p></p>






    </dd>
<dt><a name=objname></a>If the name of the symbol is a constant string</dt>
    <dd>you have these options:
	<ul>
	<li>put that symbol to the list of exceptions to prevent it from being modified 
		 
<a class=docref href=exceptions.shtml#adding-to-exceptions>adding symbols to exceptions</a>    
.

	<li>List that symbol as "quoted symbol name". In this case Perl-Obfus will replace every string
	    whose value is equal to the symbol name, with a string equal to  mangled symbol name.
	    Strings that include some other characters around symbol name won't be changed.
	    Register "quoted symbol name" in <span class=menuref>Symbols &rArr; 
	    Edit strings that contains symbol names</span> if using GUI, or put them, one symbol per line,
	    to a text file and pass its name after <code>--quoted-symbol-names</code> command line option
	    if using command line interface.


	<li>wrap that name in the call to <code>SN</code> function
 





<pre>
#before
    my $method = "process";
    $obj->$method();
#after
    my $method = SN("process");
    $obj->$method();

#before
    my $varname = "myvar";
    eval("\$$varname = 23; \$blah = 15;");
#after
    my $varname = SN("myvar");
    eval("\$$varname = 23; \$" . SN('blah') . "=15;");
</pre><p></p>

For this to work, add the following lines to the begining of your files (or make sure that these definitions 
are visible to each of your files):
<pre>
BEGIN{eval('sub SNS{@_;}sub SN{$_[0];}');}
</pre><p></p>
	</ul>
    </dd>
</dl>
GUI has special tool to help with this  - it lists all symbols found inside strings, in <span 
class=menuref>Symbols &rArr; View strings encountered in code</span>. Most probably you should copy list
of such symbols 
to <span class=menuref>Symbols &rArr; Edit strings that contains symbol names</span>, or to the 
list of exceptions (<span class=menuref>Symbols &rArr; Edit user-specified exceptions</span>), or 
alter your code by wrapping string constants with those symbols in  call to <code>SN()</code>.


<h2>Update the export tables for your modules and 'use vars' statements</h2><p>
<a name=sns></a>
Modify all modules that have @EXPORT variable defined and that use Exporter.pm, to use SN 
and SNS subroutines (read previous step for more information). 
 E.g. code before:
<pre>
BEGIN {
        use Exporter   ();
        use vars       qw($VERSION @ISA @EXPORT %h1 @list1 $var2);
        $VERSION     = 1.00;
        @ISA         = qw(Exporter);
    
        @EXPORT      = qw(%h1 @list1 $var2);
};								    
</pre><p></p>
The code should look like the following after your modifications:

<pre>
sub SN { '';$_[0]; } #return 1st argument
sub SNS { '';@_; }	#return all arguments

BEGIN {
        use Exporter   ();
        use vars       (SNS(qw($VERSION @ISA @EXPORT %h1 @list1 $var2)));
        $VERSION     = 1.00;
        @ISA         = qw(Exporter);
    
        @EXPORT      = SNS(qw(%h1 @list1 $var2));
};								    
</pre><p></p>
Note that list of names of variables in 'use vars' was wrapped in call of SNS; 
the initializer of @EXPORT was also wrapped in call of SNS();


















<a name=steps></a>
<h1>Steps for obfuscating the project with Perl-Obfus</h1><p>


<a name=step1></a>
<h2 class=step>Step  1:  add <code>SN</code> to your code</h2><p>



Alter all places where your code refers to names of symbols inside string constants, by wrapping
names of symbols into a call of <code>SN</code> or  <code>SNS</code> function,
as explained <a href=#use_objname>above</a>.

<p>
Then test that after these changes your unobfuscated code works same as your original code.





<a name=step2></a>
<h2 class=step>Step  2: collect set of exceptions for your code</h2><p>

A lot of tools for this are shipped with Perl-Obfus
<a class=docref href=exceptions.shtml#extract-exceptions>extacting list of symbols</a>    
 





<a name=step3></a>
<h2 class=step>Step  3: process your code using lite protection and test it</h2><p>


With lite protection, names of symbols that are to be made unreadable, will just get <code>ReplacementFor_</code> prefix.
This will result in error messages looking like <tt>"Undefined function ReplacementFor_SomeFunctionName"</tt>
when you'll  run your code - it will clearly indicate that
symbol <code>SomeFunctionName</code> should be added to the list of exceptions
(see more on what exceptions are <a href=#exceptions>here</a>).

<p>
Proceed to next step only if your protected code works fine.




<a name=step4></a>
<h2 class=step>Step  4: process your code using non-lite protection and test it</h2><p>

After switching protection mode to non-lite, your code should work exactly as when protected by lite protection.
Note that <b>trial</b> version of Perl-Obfus can perform only one kind of transformation for symbol names - 
by prepending prefix  <code>ReplacementFor_</code> to them. This does not limit your ability to evaluate  Perl-Obfus in any way
as mangling integers and strings in non-lite mode is the same for both trial and non-trial, so once you tested your code
protected with trial in non-lite mode, you will need only minimal testing of code once upgrading trial into non-trial of
 Perl-Obfus.







<style type=text/css>
a.docref:before { content: "[see \""; }
a.docref:after { content: "\"]"; }
a.docref { font-size: 70%; }

h2 { font-size: 120%; padding-top: 1em; padding-left: 2em; }
dl { padding-top: 0em; } 

.menuref { font-style: italic; } /* references to menu items */

span.wrap_condition { border: solid 1px black; }
span.wrap_condition_0 { background: #ffe; }
span.wrap_condition_1 { background: #fef; }
span.wrap_condition_2 { background: #eff; }
span.wrap_condition_3 { background: #eef; }
</style>

<!---AFTER_DOC_CONTENT-->
