template<typename E>E modInv(const E&P,const E&M){assert(P!=0);E w=0,N=1,U=P,Q=M,A;while(U!=0){A=Q/U;std::swap(U,Q-=A*U);std::swap(w-=A*N,N);}assert(Q==1);return w;}template<typename Mod>class MB{using F=typename std::decay<decltype(Mod::value)>::type;F value;constexpr static F o(){return Mod::value;}template<typename E>E L(E P){F H=static_cast<F>(-o()<P&&P<o()?P:P%o());return(H<0?H+=o():H);}public:constexpr MB():value(){}template<typename E>MB(const E&P){value=L(P);}template<typename E>explicit operator E()const{return static_cast<E>(value);}const F&operator()()const{return value;}MB&operator+=(const MB&P){if((value+=P.value)>=o())value-=o();return*this;}MB&operator-=(const MB&P){if((value-=P.value)<0)value+=o();return*this;}MB&operator*=(const MB&P){if constexpr(std::is_same<F,int>::value)value=L(static_cast<int64_t>(value)*P.value);else value=L(value*P.value);return*this;}MB&operator/=(const MB&P){return*this*=MB(modInv(P.value,o()));}template<typename E>typename std::enable_if<std::is_integral<E>::value,MB>::type&operator^=(E P){if(P<0)return*this=MB(modInv(static_cast<F>(1),(*this^(-P))()));MB e=*this;for(*this=static_cast<F>(1);P;P>>=1){if(P&1)*this*=e;e*=e;}return*this;}MB operator-()const{return MB(-value);}MB&operator++(){return*this+=1;}MB&operator--(){return*this-=1;}MB operator++(int){MB e=*this;++*this;return e;}MB operator--(int){MB e=*this;--*this;return e;}MB operator+(const MB&P)const{return MB(*this)+=P;}MB operator-(const MB&P)const{return MB(*this)-=P;}MB operator*(const MB&P)const{return MB(*this)*=P;}MB operator/(const MB&P)const{return MB(*this)/=P;}bool operator==(const MB&P)const{return value==P.value;}bool operator!=(const MB&P)const{return value!=P.value;}bool operator<=(const MB&P)const{return value<=P.value;}bool operator>=(const MB&P)const{return value>=P.value;}bool operator<(const MB&P)const{return value<P.value;}bool operator>(const MB&P)const{return value>P.value;}bool operator!()const{return value;}template<typename q,typename E>friend q&operator>>(q&,MB<E>&);template<typename I,typename E>friend I&operator<<(I&,const MB<E>&);template<typename N>friend MB operator+(const MB&J,const N&P){return J+MB(P);}template<typename N>friend MB operator+(const N&J,const MB&P){return MB(J)+P;}template<typename N>friend MB operator-(const MB&J,const N&P){return J-MB(P);}template<typename N>friend MB operator-(const N&J,const MB&P){return MB(J)-P;}template<typename N>friend MB operator*(const MB&J,const N&P){return J*MB(P);}template<typename N>friend MB operator*(const N&J,const MB&P){return MB(J)*P;}template<typename N>friend MB operator/(const MB&J,const N&P){return J/MB(P);}template<typename N>friend MB operator/(const N&J,const MB&P){return MB(J)/P;}template<typename N>friend typename std::enable_if<std::is_integral<N>::value,MB>::type operator^(MB J,const N&P){return J^=P;}template<typename N>friend MB operator+=(MB&J,const N&P){return J+=MB(P);}template<typename N>friend MB operator-=(MB&J,const N&P){return J-=MB(P);}template<typename N>friend MB operator*=(MB&J,const N&P){return J*=MB(P);}template<typename N>friend MB operator/=(MB&J,const N&P){return J/=MB(P);}template<typename N>friend MB operator==(const MB&J,const N&P){return J==MB(P);}template<typename N>friend MB operator==(const N&J,const MB&P){return MB(J)==P;}template<typename N>friend MB operator!=(const MB&J,const N&P){return J!=MB(P);}template<typename N>friend MB operator!=(const N&J,const MB&P){return MB(J)!=P;}template<typename N>friend MB operator<=(const MB&J,const N&P){return J<=MB(P);}template<typename N>friend MB operator<=(const N&J,const MB&P){return MB(J)<=P;}template<typename N>friend MB operator>=(const MB&J,const N&P){return J>=MB(P);}template<typename N>friend MB operator>=(const N&J,const MB&P){return MB(J)>=P;}template<typename N>friend MB operator<(const MB&J,const N&P){return J<MB(P);}template<typename N>friend MB operator<(const N&J,const MB&P){return MB(J)<P;}template<typename N>friend MB operator>(const MB&J,const N&P){return J>MB(P);}template<typename N>friend MB operator>(const N&J,const MB&P){return MB(J)>P;}};template<typename q,typename E>q&operator>>(q&g,MB<E>&J){typename MB<E>::F K;g>>K;J.value=J.L(K);return g;}template<typename I,typename E>I&operator<<(I&C,const MB<E>&P){return C<<P.value;}
using ModType = ${1:int};
$3constexpr ModType MOD = ${2:1e9 + 7};
$3using Modular = MB<std::integral_constant<ModType, MOD>>;
$3// struct b { static ModType D; };
$3// ModType &Mod = b::D;
$3// using Modular = MB<b>;
struct Fact{Fact(const int&E):d(E+1,Modular(1)),I(E+1),Z(E){d[0]=1;for(int Y=1;Y<=E;Y++)d[Y]=d[Y-1]*Y;I[E]=Modular(1)/d[E];for(int Y=E;Y>=1;Y--)I[Y-1]=I[Y]*Y;}Modular C(const int&E,const int&F)const{if(E<0||F<0||E<F)return 0;if(E>Z)throw std::out_of_range("\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u006E\u0020\u003C\u0020"+std::to_string(Z)+"\u002C\u0020\u0062\u0075\u0074\u0020\u0066\u006F\u0075\u006E\u0064\u0020\u006E\u0020\u003D\u0020"+std::to_string(E)+"\u002E");return d[E]*I[F]*I[E-F];}Modular A(const int&E,const int&F)const{if(E<0||F<0||E<F)return 0;if(E>Z)throw std::out_of_range("\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u006E\u0020\u003C\u0020"+std::to_string(Z)+"\u002C\u0020\u0062\u0075\u0074\u0020\u0066\u006F\u0075\u006E\u0064\u0020\u006E\u0020\u003D\u0020"+std::to_string(E)+"\u002E");return d[E]*I[E-F];}private:std::vector<Modular>d,I;const int Z;};
$0