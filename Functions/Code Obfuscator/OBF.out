#include <bits/stdc++.h>
template <typename E>
E modInv(const E& P, const E& M) { // P * w â‰¡ 1 (o M)
    assert(P != 0);
    E w = 0, N = 1, U = P, Q = M, A;
    while (U != 0) {
        A = Q / U;
        std::swap(U, Q -= A * U);
        std::swap(w -= A * N, N);
    }
    assert(Q == 1);
    return w;
}
template<typename Mod>
class Modular_Base {
    using F = typename std::decay<decltype(Mod::value)>::type;
    F value;
    constexpr static F o() { return Mod::value; }
    template<typename E> E L(E P) {
        F H = static_cast<F>(-o() < P && P < o() ? P : P % o());
        return (H < 0 ? H += o() : H);
    }
public:
    constexpr Modular_Base() : value() {}
    template<typename E> Modular_Base(const E &P) { value = L(P); }
    template<typename E> explicit operator E() const { return static_cast<E>(value); }
    const F& operator()() const { return value; }
    Modular_Base& operator+=(const Modular_Base& P) {
        if ((value += P.value) >= o()) value -= o();
        return *this;
    }
    Modular_Base& operator-=(const Modular_Base& P) {
        if ((value -= P.value) < 0) value += o();
        return *this;
    }
    Modular_Base& operator*=(const Modular_Base& P) {
        if constexpr (std::is_same<F, int>::value) 
            value = L(static_cast<int64_t>(value) * P.value);
        else value = L(value * P.value);
        return *this;
    }
    Modular_Base& operator/=(const Modular_Base& P) { return *this *= Modular_Base(modInv(P.value, o())); }
    template<typename E> typename std::enable_if<std::is_integral<E>::value, Modular_Base>::type& operator^=(E P) {
        if (P < 0) return *this = Modular_Base(modInv(static_cast<F>(1), (*this ^ (-P))()));
        Modular_Base e = *this;
        for (*this = static_cast<F>(1); P; P >>= 1) {
            if (P & 1) *this *= e;
            e *= e;
        }
        return *this;
    }
    Modular_Base operator-() const { return Modular_Base(-value); }
    Modular_Base& operator++() { return *this += 1; }
    Modular_Base& operator--() { return *this -= 1; }
    Modular_Base operator++(int) { Modular_Base e = *this; ++*this; return e; }
    Modular_Base operator--(int) { Modular_Base e = *this; --*this; return e; }
    Modular_Base operator+(const Modular_Base& P) const { return Modular_Base(*this) += P; }
    Modular_Base operator-(const Modular_Base& P) const { return Modular_Base(*this) -= P; }
    Modular_Base operator*(const Modular_Base& P) const { return Modular_Base(*this) *= P; }
    Modular_Base operator/(const Modular_Base& P) const { return Modular_Base(*this) /= P; }
    bool operator==(const Modular_Base& P) const { return value == P.value; }
    bool operator!=(const Modular_Base& P) const { return value != P.value; }
    bool operator<=(const Modular_Base& P) const { return value <= P.value; }
    bool operator>=(const Modular_Base& P) const { return value >= P.value; }
    bool operator<(const Modular_Base& P) const { return value < P.value; }
    bool operator>(const Modular_Base& P) const { return value > P.value; }
    bool operator!() const { return value; }
    template<typename q, typename E> friend q& operator>>(q& , Modular_Base<E>& );
    template<typename I, typename E> friend I& operator<<(I& , const Modular_Base<E>& );
    template<typename N> friend Modular_Base operator+(const Modular_Base& J, const N& P) { return J + Modular_Base(P); }
    template<typename N> friend Modular_Base operator+(const N& J, const Modular_Base& P) { return Modular_Base(J) + P; }
    template<typename N> friend Modular_Base operator-(const Modular_Base& J, const N& P) { return J - Modular_Base(P); }
    template<typename N> friend Modular_Base operator-(const N& J, const Modular_Base& P) { return Modular_Base(J) - P; }
    template<typename N> friend Modular_Base operator*(const Modular_Base& J, const N& P) { return J * Modular_Base(P); }
    template<typename N> friend Modular_Base operator*(const N& J, const Modular_Base& P) { return Modular_Base(J) * P; }
    template<typename N> friend Modular_Base operator/(const Modular_Base& J, const N& P) { return J / Modular_Base(P); }
    template<typename N> friend Modular_Base operator/(const N& J, const Modular_Base& P) { return Modular_Base(J) / P; }
    template<typename N> friend typename std::enable_if<std::is_integral<N>::value, Modular_Base>::type operator^(Modular_Base J, const N& P) { return J ^= P; }
    template<typename N> friend Modular_Base operator+=(Modular_Base& J, const N& P) { return J += Modular_Base(P); }
    template<typename N> friend Modular_Base operator-=(Modular_Base& J, const N& P) { return J -= Modular_Base(P); }
    template<typename N> friend Modular_Base operator*=(Modular_Base& J, const N& P) { return J *= Modular_Base(P); }
    template<typename N> friend Modular_Base operator/=(Modular_Base& J, const N& P) { return J /= Modular_Base(P); }
    template<typename N> friend Modular_Base operator==(const Modular_Base& J, const N& P) { return J == Modular_Base(P); }
    template<typename N> friend Modular_Base operator==(const N& J, const Modular_Base& P) { return Modular_Base(J) == P; }
    template<typename N> friend Modular_Base operator!=(const Modular_Base& J, const N& P) { return J != Modular_Base(P); }
    template<typename N> friend Modular_Base operator!=(const N& J, const Modular_Base& P) { return Modular_Base(J) != P; }
    template<typename N> friend Modular_Base operator<=(const Modular_Base& J, const N& P) { return J <= Modular_Base(P); }
    template<typename N> friend Modular_Base operator<=(const N& J, const Modular_Base& P) { return Modular_Base(J) <= P; }
    template<typename N> friend Modular_Base operator>=(const Modular_Base& J, const N& P) { return J >= Modular_Base(P); }
    template<typename N> friend Modular_Base operator>=(const N& J, const Modular_Base& P) { return Modular_Base(J) >= P; }
    template<typename N> friend Modular_Base operator<(const Modular_Base& J, const N& P) { return J < Modular_Base(P); }
    template<typename N> friend Modular_Base operator<(const N& J, const Modular_Base& P) { return Modular_Base(J) < P; }
    template<typename N> friend Modular_Base operator>(const Modular_Base& J, const N& P) { return J > Modular_Base(P); }
    template<typename N> friend Modular_Base operator>(const N& J, const Modular_Base& P) { return Modular_Base(J) > P; }
};
template<typename q, typename E>
q& operator>>(q& g, Modular_Base<E>& J) {
    typename Modular_Base<E>::F K; g >> K;
    J.value = J.L(K);
    return g;
}
template<typename I, typename E>
I& operator<<(I& C, const Modular_Base<E>& P) { return C << P.value; }
using ModType = int;
constexpr ModType MOD = 1e9 + 7;
using Modular = Modular_Base<std::integral_constant<ModType, MOD>>;
// struct l { static ModType value; };
// ModType &Mod = l::value;
// using Modular = Modular_Base<l>;
struct Fact {
    std::vector<Modular> c, X;
    const int j;
    Fact(const int &s) : c(s+1, Modular(1)), X(s+1), j(s) {
        c[0] = 1;
        for (int B = 1; B <= s; B++) c[B] = c[B-1] * B;
        X[s] = Modular(1) / c[s];
        for (int B = s; B >= 1; B--) X[B-1] = X[B] * B;
    }
    Modular C(const int &s, const int &Q) const {
        if (s < 0 || Q < 0 || s < Q) return 0;
        if (s > j) throw std::out_of_range("\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u006E\u0020\u003C\u0020" + std::to_string(j) + "\u002C\u0020\u0062\u0075\u0074\u0020\u0066\u006F\u0075\u006E\u0064\u0020\u006E\u0020\u003D\u0020" + std::to_string(s) + "\u002E");
        return c[s] * X[Q] * X[s - Q];
    }
    Modular A(const int &s, const int &Q) const {
        if (s < 0 || Q < 0 || s < Q) return 0;
        if (s > j) throw std::out_of_range("\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u006E\u0020\u003C\u0020" + std::to_string(j) + "\u002C\u0020\u0062\u0075\u0074\u0020\u0066\u006F\u0075\u006E\u0064\u0020\u006E\u0020\u003D\u0020" + std::to_string(s) + "\u002E");
        return c[s] * X[s - Q];
    }
};
int main() {
    1 + Modular(1);
    Modular p = 1;
    return 0;
}