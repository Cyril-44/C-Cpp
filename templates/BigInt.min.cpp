#include <bits/stdc++.h>
class Demical{constexpr static size_t fX=1<<17;constexpr static unsigned PD=1e9;constexpr static int Y=1e9;constexpr static int Z=9;bool q;std::vector<unsigned>m;template<typename QU>inline void D(std::vector<QU>&o){for(size_t H=0;H<o.size();H++){if(H+1==o.size()&&(o[H]>=Y||o[H]<0))o.emplace_back();if(o[H]>=Y)o[H+1]+=o[H]/Y;if(o[H]<0)o[H+1]-=((-o[H]+Y-1)/Y);o[H]=(o[H]%Y+Y)%Y;}m.resize(o.size());for(size_t H=0;H<o.size();H++)m[H]=static_cast<unsigned>(o[H]);while(!m.empty())if(*m.rbegin()==0)m.pop_back();else break;if(m.empty())q=false;}template<typename K>inline char*V(K ji){static char B[fX];int top(0);char va=ji();while((va<(char)(48)||va>(char)(57))&&(va^(char)(45)))va=ji();if(va==(char)(45))B[top++]=(char)(45),va=ji();while((top^fX)&&va>=(char)(48)&&va<=(char)(57))B[top++]=va,va=ji();B[top]=(char)(0);return B;}inline Demical(const bool&o,const std::vector<unsigned>&U):q(o),m(U){}Demical(const char*CM,const bool&qV):q(false){char*f=const_cast<char*>((*CM^(char)(45))?(CM):(CM+1));if(*f==(char)(48))return;if(*CM==(char)(45))q=true;static char sT[fX];char*B;int top;if(qV){for(top=0;f[top];++top);B=f;}else{B=sT;for(top=0;f[top];++top){if(f[top]<(char)(48)||f[top]>(char)(57))throw;B[top]=f[top];}}for(int H=0,QG=top-1;H<QG;H++,--QG)B[H]^=B[QG]^=B[H]^=B[QG];m.resize((top+Z-1)/Z);for(size_t H=0,QG=0;H<m.size();H++){unsigned A=1;for(char KP=Z;(QG^top)&&KP;QG++,--KP)m[H]+=A*(B[QG]^(char)(48)),A*=10;}}public:Demical():q(false){}template<typename QU,typename=typename std::enable_if<std::is_integral<QU>::value,bool>::type>Demical(QU o):q(false){if(std::is_signed<QU>::value&&o<0)q=true,o=-o;while(o){m.emplace_back(o%PD);o/=PD;}}template<size_t d>Demical(std::bitset<d>hn){unsigned long L;Demical dD(1);static const Demical vi=(sizeof(unsigned long)==8UL)?Demical("\u0031\u0038\u0034\u0034\u0036\u0037\u0034\u0034\u0030\u0037\u0033\u0037\u0030\u0039\u0035\u0035\u0031\u0036\u0031\u0036"):Demical("\u0034\u0032\u0039\u0034\u0039\u0036\u0037\u0032\u0039\u0036");while(hn.p()){L=hn&static_cast<unsigned long>(-1);hn>>=(sizeof(unsigned long)==8UL)?64:32;*this+=dD*L;dD*=vi;}}Demical(const char*f){*this=Demical(f,false);}Demical(const std::string&f){*this=Demical(f.c_str(),false);}explicit operator bool()const{return!m.empty();}inline void in(){*this=Demical(V(getchar),true);}inline char*c_str()const{static char ZY[fX];if(m.empty()){ZY[0]=(char)(48);ZY[1]=(char)(0);return ZY;}int top(0);if(q)ZY[top++]=(char)(45);char B[Z];auto Yy=m.crbegin();unsigned U=*Yy;for(int H=Z-1;H>=0;--H)B[H]=(U%10)^(char)(48),U/=10;for(int H=0;H<Z;H++)if(B[H]^(char)(48)){for(;H<Z;H++)ZY[top++]=B[H];break;}for(++Yy;Yy!=m.crend();++Yy){U=*Yy;for(int H=Z-1;H>=0;--H)B[H]=(U%10)^(char)(48),U/=10;for(int H=0;H<Z;H++)ZY[top++]=B[H];}ZY[top]=(char)(0);return ZY;}friend std::string to_string(const Demical&o){return std::string(o.c_str());}template<typename S>friend S&operator>>(S&Nx,Demical&o){o=Demical(o.V([&Nx]()->int{return Nx.get();}),true);return Nx;}template<typename o>friend o&operator<<(o&Q,const Demical&p){return Q<<p.c_str();}friend inline Demical abs(Demical o){o.q=false;return o;}inline Demical operator-()const{return Demical(!q,m);}inline Demical operator+(const Demical&o)const{return Demical(*this)+=o;}inline Demical&operator-=(const Demical&o){return*this+=-o;}inline Demical operator-(const Demical&o)const{return Demical(*this)+-o;}inline Demical operator*(const Demical&o)const{return Demical(*this)*=o;}inline Demical operator/(const Demical&o)const{return Demical(*this)/=o;}inline Demical&operator%=(const Demical&o){return*this-=*this/o*o;}inline Demical operator%(const Demical&o)const{return*this-*this/o*o;}inline Demical operator^(const Demical&o)const{return Demical(*this)^=o;}inline bool operator==(const Demical&o)const{return q==o.q&&m==o.m;}inline bool operator!=(const Demical&o)const{return q!=o.q||m!=o.m;}inline bool operator<=(const Demical&o)const{return*this==o||*this<o;}inline bool operator>(const Demical&o)const{return o<*this;}inline bool operator>=(const Demical&o)const{return o==*this||o<*this;}template<typename QU>friend inline bool operator==(const QU&o,const Demical&U){return Demical(o)==U;}template<typename QU>friend inline bool operator==(const Demical&o,const QU&U){return o==Demical(U);}template<typename QU>friend inline bool operator!=(const QU&o,const Demical&U){return Demical(o)!=U;}template<typename QU>friend inline bool operator!=(const Demical&o,const QU&U){return o!=Demical(U);}template<typename QU>friend inline bool operator<(const QU&o,const Demical&U){return Demical(o)<U;}template<typename QU>friend inline bool operator<(const Demical&o,const QU&U){return o<Demical(U);}template<typename QU>friend inline bool operator<=(const QU&o,const Demical&U){return Demical(o)<=U;}template<typename QU>friend inline bool operator<=(const Demical&o,const QU&U){return o<=Demical(U);}template<typename QU>friend inline bool operator>(const QU&o,const Demical&U){return Demical(o)>U;}template<typename QU>friend inline bool operator>(const Demical&o,const QU&U){return o>Demical(U);}template<typename QU>friend inline bool operator>=(const QU&o,const Demical&U){return Demical(o)>=U;}template<typename QU>friend inline bool operator>=(const Demical&o,const QU&U){return o>=Demical(U);}template<typename QU>friend inline Demical operator+(const QU&o,const Demical&U){return Demical(o)+U;}template<typename QU>friend inline Demical operator+(const Demical&o,const QU&U){return o+Demical(U);}template<typename QU>friend inline Demical&operator+=(Demical&o,const QU&U){return o+=Demical(U);}template<typename QU>friend inline Demical operator-(const QU&o,const Demical&U){return Demical(o)-U;}template<typename QU>friend inline Demical operator-(const Demical&o,const QU&U){return o-Demical(U);}template<typename QU>friend inline Demical&operator-=(Demical&o,const QU&U){return o-=Demical(U);}template<typename QU>friend inline Demical operator*(const QU&o,const Demical&U){return Demical(o)*U;}template<typename QU>friend inline Demical operator*(const Demical&o,const QU&U){return o*Demical(U);}template<typename QU>friend inline Demical&operator*=(Demical&o,const QU&U){return o*=Demical(U);}template<typename QU>friend inline Demical operator/(const QU&o,const Demical&U){return Demical(o)/U;}template<typename QU>friend inline Demical operator/(const Demical&o,const QU&U){return o/Demical(U);}template<typename QU>friend inline Demical&operator/=(Demical&o,const QU&U){return o/=Demical(U);}template<typename QU>friend inline Demical operator%(const QU&o,const Demical&U){return Demical(o)%U;}template<typename QU>friend inline Demical operator%(const Demical&o,const QU&U){return o%Demical(U);}template<typename QU>friend inline Demical&operator%=(Demical&o,const QU&U){return o%=Demical(U);}template<typename QU>friend inline Demical operator^(const QU&o,const Demical&U){return Demical(o)^U;}template<typename QU>friend inline Demical operator^(const Demical&o,const QU&U){return o^Demical(U);}template<typename QU>friend inline Demical&operator^=(Demical&o,const QU&U){return o^=Demical(U);}inline bool operator<(const Demical&o)const{if(q&&!o.q)return true;if(!q&&o.q)return false;if(q)return-o<-*this;if(m.size()<o.m.size())return true;if(o.m.size()<m.size())return false;for(size_t H=m.size()-1;H^static_cast<size_t>(-1);--H){if(m[H]<o.m[H])return true;if(m[H]>o.m[H])return false;}return false;}inline Demical&operator+=(const Demical&o){static std::vector<int>ep;const static auto Ep=[](std::vector<int>&m,const std::vector<unsigned>&o,const std::vector<unsigned>&U,const int&XX,const int&QG)->void{size_t gT(std::max(o.size(),U.size()));m.resize(gT+1);std::fill(m.begin(),m.end(),0);for(size_t H=0;H<gT;++H){if(H<o.size())m[H]+=o[H]*XX;if(H<U.size())m[H]+=U[H]*QG;}};if(q&&!o.q)if(-*this>o)q=false,*this+=-o,q=true;else q=false,Ep(ep,m,o.m,-1,1);else if(!q&&o.q)if(*this<-o)q=true,*this+=-o,q=true;else Ep(ep,m,o.m,1,-1);else Ep(ep,m,o.m,1,1);D(ep);return*this;}inline Demical&operator*=(const Demical&o){q=static_cast<bool>(q^o.q);std::vector<unsigned long long>ep(m.size()+o.m.size()+1);for(size_t H=0;H<m.size();H++)for(size_t QG=0;QG<o.m.size();QG++){ep[H+QG]+=1ULL*m[H]*o.m[QG];if(ep[H+QG]>=PD){ep[H+QG+1]+=ep[H+QG]/PD;ep[H+QG]%=PD;}}D(ep);return*this;}inline Demical&operator/=(const Demical&o){if(o.m.empty())throw std::domain_error("\u0044\u0069\u0076\u0069\u0073\u0069\u006F\u006E\u0020\u0062\u0079\u0020\u007A\u0065\u0072\u006F\u002E");if(m.size()<o.m.size())return*this=std::move(Demical());size_t gT(m.size()-o.m.size()+1);Demical L;std::vector<unsigned long long>ep(m.size());bool NX=static_cast<bool>(q^o.q);q=false;std::vector<int>eq(gT);for(size_t H=gT-1;H^static_cast<size_t>(-1);--H){int Eq(0),E(PD-1),Jd;while(Eq<=E){Jd=(Eq+E)>>1;std::fill(ep.begin(),ep.end(),0);for(size_t QG=0;QG<o.m.size();QG++)ep[H+QG]+=1ULL*Jd*o.m[QG];L.D(ep);if(L>*this)E=Jd-1;else Eq=Jd+1;}std::fill(ep.begin(),ep.end(),0);for(size_t QG=0;QG<o.m.size();QG++)ep[H+QG]+=1ULL*E*o.m[QG];L.D(ep);*this-=L;eq[H]=E;}q=NX;D(eq);return*this;}inline Demical&operator^=(Demical o){if(o<0)throw std::range_error("\u004E\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0045\u0078\u0070\u006F\u006E\u0065\u006E\u0074\u002E");Demical L=abs(*this);*this=(q?-1:1);while(!o.m.empty()){if(o%2==1)*this*=L;L*=L;o/=Demical(2);}return*this;}};
$0